[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Random thoughts, problems, projects. It helps me refresh my memory and hopefully helps others."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Idea Factory",
    "section": "",
    "text": "All-Pairs Grid Neighbors\n\n\n\n\n\n\n\ncode\n\n\npython\n\n\ngraph theory\n\n\nnumpy\n\n\npermutations\n\n\n\n\nFrom a list of labels, construct a grid where each two labels are neighbors at least once, and no label is a neighbor of itself.\n\n\n\n\n\n\nJan 8, 2023\n\n\nO. Masoud\n\n\n\n\n\n\n  \n\n\n\n\nSub-Penny Precision Handling of Financial Data\n\n\n\n\n\n\n\ncode\n\n\nanalysis\n\n\nfinance\n\n\n\n\nAnalysis of financial data sub-penny precision and how to deal with it.\n\n\n\n\n\n\nDec 1, 2022\n\n\nO. Masoud\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/grid-neighbors/grid-neighbors.html",
    "href": "posts/grid-neighbors/grid-neighbors.html",
    "title": "All-Pairs Grid Neighbors",
    "section": "",
    "text": "I came across this problem while working on a method to generate a color palette consisting of \\(n\\), where all colors are visibly different from one another. I wanted compact way of visualizing the palette to see what colors are too close to each other, and which ones are far enough apart. One way would be to list all \\(\\frac{n*(n-1)}{2}\\) pairs of colors, but that would be a long one-dimensional list. What I wanted instead is to visualize the colors in a grid that is guaranteed to have each pair of colors present somewhere as neighbors, and where no two neighbors are the same color. The second condition is of course necessary since we are trying to create a tool for comparing different colors by showing them as adjacent cells, and hence we want to make sure we are not repeating the color in two adjacent cells.\n\nProblem Statement\n\nThe problem we are trying to solve can be stated as follows:\n\nGiven an integer \\(n\\), construct a grid where each cell contains an integers in \\([0, n-1]\\), such that,\n\n\nevery possible pair of integers \\((i,j)\\), \\(i \\ne j\\), \\(i\\), \\(j\\) in \\([0, n-1]\\) is present at least once as two horizontally or vertically adjacent cells in the grid, and,\n\n\n\nno two horizontally or vertically adjacent cells contain the same integer.\n\n\n\nNote that \\((i,j)\\) is present \\(\\iff\\) \\((j,i)\\) is also present, and hence they are essentially the same pair.\nIdeally, the grid should be as small as possible. But let us not worry about that for now.\nWe know the grid cannot contain less than \\(n\\) cells, otherwise we would be missing some numbers; but that is too low of lower bound on the grid size. Let us see if we can find a lower bound higher than this.\nA grid of size \\(r \\times c\\) can represent at most \\((r-1)c + (c-1)r\\) pairs because that is the number of internal edges, each of which shared by two cells (and so, excluding edges on the outer border).\nFurther, we only need to consider square grids to find a lower bound. This follows from the claim that of all grid sizes containing the same number of internal edges, the smallest grid size, if size is measured by the number of cells, must have \\(r=c\\). The proof is as follows. If we call the number of internal edges \\(e\\), where \\(e = (r-1)c + (c-1)r\\) and the grid size \\(s\\), where \\(s = rc\\), then,\n\n\n\\[c = \\frac{e + r}{2 r - 1} \\tag{1} \\]\n\n\n\\[s = c r = \\frac{r \\left(e + r\\right)}{2 r - 1} \\tag{2} \\]\n\n\n\n\n\\[ \\frac{\\partial s}{\\partial r} =\\frac{- e + 2 r^{2} - 2 r}{\\left(2 r - 1\\right)^{2}} \\tag{3} \\]\n\n\n\n\nSetting \\(\\frac{\\partial s}{\\partial r}=0\\) we get:\n\n\n\\[r_{min} = \\frac{\\sqrt{2 e + 1}}{2} + \\frac{1}{2} \\tag{4} \\]\n\n\n\n\nSubsituting \\(r_{min}\\) from \\((4)\\) into \\((1)\\) we get:\n\n\n\\[c_{min} = \\frac{2 e + \\sqrt{2 e + 1} + 1}{2 \\sqrt{2 e + 1}} = \\frac{\\sqrt{2 e + 1}}{2} + \\frac{1}{2} = r_{min} \\tag{5} \\]\n\n\n\n\nHence, the square grid is an extremum. Note that the second derivative of \\(s\\) is:\n\n\n\\[ \\frac{\\partial^2 s}{\\partial r^2}=\\frac{2 \\cdot \\left(2 e + 1\\right)}{\\left(2 r - 1\\right)^{3}} \\tag{6} \\]\n\n\n\n\nSubsituting \\(r_{min}\\) from \\((4)\\) into \\((6)\\) we get:\n\n\n\\[\\frac{\\partial^2 s}{\\partial r^2}(r_{min})=\\frac{2}{\\sqrt{2 e + 1}} \\gt 0 \\tag{7} \\]\n\n\nwhich is a positive constant and therefore, the square grid with \\(r = c = r_{min} = c_{min}\\) is where the grid size, \\(s\\), is minimum.\nBy setting \\(e = \\frac{n(n-1)}{2}\\), which is the total number of pairs, and substituting in \\((4)\\), we can establish the a lower bound on the dimension \\(d\\), (\\(r=c=d\\)), of the grid:\n\n\n\\[ d \\ge \\frac{\\sqrt{n \\left(n - 1\\right) + 1}}{2} + \\frac{1}{2} \\tag{8} \\]\n\n\n\n\nAs a fraction of \\(n\\), this converges to:\n\n\n\\[ \\lim_{n \\to \\infty}\\left(\\frac{\\frac{\\sqrt{n \\left(n - 1\\right) + 1}}{2} + \\frac{1}{2}}{n}\\right)=\\frac{1}{2} \\tag{9} \\]\n\n\nTherefore, the solution cannot be achieved with a grid size smaller than \\(\\frac{n}{2} \\times \\frac{n}{2}\\). The optimum solution may of course be higher than this theoretical lower bound.\n\n\nSolutions\nI could not find much information about this problem except for a relevant stackoverflow question that did not seem to have received much attention. A solution among the answers proposed to start by placing a number in the corner and build the grid by adding numbers iteratively towards satisfying the constraints. This could be an interesting approach but I have not tried it yet.\nA possible basic solution is to take the full list of pairs and arrange them in a grid. For example, the first row could contain the sequence of the following \\(n-1\\) pairs, which when arranged this way, will not have any number adjacent to itself: \\[(\\phantom{nnn}0,\\phantom{nnn}1), (\\phantom{nnn}0,2), (\\phantom{nnn}0,3), \\dotsc, (\\phantom{nnn}0,n-2), (\\phantom{nnn}0,n-1)\\] Following this pattern, whose odd columns resemble a Toeplitz matrix, the remaining rows will contain \\[(\\phantom{nnn}1,\\phantom{nnn}2), (\\phantom{nnn}1,3), (\\phantom{nnn}1,4), \\dotsc, (\\phantom{nnn}1,n-1), (\\phantom{nnn}1,\\phantom{nnn}0)\\] \\[(\\phantom{nnn}2,\\phantom{nnn}3), (\\phantom{nnn}2,4), (\\phantom{nnn}2,5), \\dotsc, (\\phantom{nnn}2,\\phantom{nnn}0), (\\phantom{nnn}2,\\phantom{nnn}1)\\] \\[ \\dotsc \\] \\[(n-2,n-1), (n-2,0), (n-2,1), \\dotsc, (n-2,n-4), (n-2,n-3)\\] \\[(n-1,\\phantom{nnn}0), (n-1,1), (n-1,2), \\dotsc, (n-1,n-3), (n-1,n-2)\\]\nSince the \\(i^{th}\\) row contains all pairs that begin with \\(i\\), the \\(n\\) rows of the grid contain all possible pairs. In addition, because each column always contains an increasing sequence (modulo \\(n\\)) of numbers, there are no self-adjacent numbers vertically. Therefore, the grid satisfies the two conditions we wanted. The size of this grid is \\(n \\times 2(n-1)\\).\nLooking at this arrangement, and given that a pair \\((a,b)\\) is equivalent to a pair \\((b,a)\\), it is easy to observe that the pairs represented by last two columns are equivalent to the pairs represented by the first two columns, shifted cyclically down by one row. The same is true for the third and fourth to last columns, which are equivalent to the third and fourth columns shifted cyclically down by two rows, and so on. This means that we can reduce the size of the grid by about half, by only considering the first \\(\\lfloor \\frac{p+1}{2} \\rfloor\\) pairs, where \\(p=n-1\\) is the number of pairs per row. Hence, the size of the grid can now be reduced to \\(n \\times 2\\lfloor \\frac{n}{2} \\rfloor\\).\nIt can also be shown that the first three columns can be removed if \\(n>=6\\). This is because the first two columns capture only \\(k\\) and \\(k+1 \\pmod n\\) pairs, which are abundantly represented throughout the grid. Additionally, the pairs generated by the 3rd and 4th columns are the same pairs generated by the 4th and 5th. The size of the grid can now be reduced to \\(n \\times (2\\lfloor \\frac{n}{2} \\rfloor - 3)\\) if \\(n>=6\\).\nAnother possible solution is as follows. We will keep horizontal adjacency constant throughout and focus on vertical adjacency. We start with the sequence \\(0,1,2,\\dotsc,n-1\\) as the first row. Then, in the second row, place a (cyclically) shifted by \\(1\\) version of the first row: \\(n-1,0,1,2,\\dotsc,n-2\\). With this, each number is now below the number that is next to it in the sequence (e.g., \\(0\\) is under \\(1\\)). In the third row, place a (cyclically) shifted by \\(2\\) version of the second row (i.e., by \\(3\\) of the first row): \\(n-3,n-2,n-1,0,1,\\dotsc,n-4\\). Now \\(0\\) is under \\(2\\). This way, with every new row, each number gets to be vertically adjacent to a new number (one number higher than what it was adjacent to in the previous row). The amount of shift in terms of the first row will be \\(1,3,6,10,15,\\dotsc\\). Essentially, we have the sequence of all the numbers walking past the sequence of all the numbers and therefore each number gets to meet each other number, just like when the players of two teams line up and walk past each other to shake hands. Hence, we will call this solution the players handshake algorithm.\n\n\n\nClick Me\n\n\n\n\n\n\n\n\nThis pattern needs to stop before a number becomes vertically adjacent to itself, which would take \\(n\\) rows. But we can stop earlier. To see this, let us take a look at the full matrix of the grid with \\(n=5\\),\n\\[ \\begin{bmatrix} 0 & 1 & 2 & 3 & 4 \\\\ 4 & 0 & 1 & 2 & 3 \\\\ 2 & 3 & 4 & 0 & 1 \\\\ 4 & 0 & 1 & 2 & 3 \\\\ 0 & 1 & 2 & 3 & 4 \\end{bmatrix} \\]\nand with \\(n=6\\),\n\\[ \\begin{bmatrix} 0 & 1 & 2 & 3 & 4 & 5 \\\\ 5 & 0 & 1 & 2 & 3 & 4 \\\\ 3 & 4 & 5 & 0 & 1 & 2 \\\\ 0 & 1 & 2 & 3 & 4 & 5 \\\\ 2 & 3 & 4 & 5 & 0 & 1 \\\\ 3 & 4 & 5 & 0 & 1 & 2 \\end{bmatrix} \\]\nIn the second row of these matrices, we established \\(n\\) new vertical pairs, and in each subsequent row, another set of \\(n\\) new pairs are added. Since the total number of possible pairs is \\(\\frac{n(n-1)}{2}\\), we should be able to stop after \\(\\frac{n-1}{2}\\) rows. It can be seen in the above two matrices that the first two rows and the last two rows contain the same vertical pairs, and so on. When \\(n=5\\), we need 3 rows to get all the pairs, and when \\(n=6\\), we need 4 rows to get all the pairs. Hence, the number of rows needed is \\(\\lceil \\frac{n+1}{2} \\rceil\\) (or \\(\\lfloor \\frac{n}{2} \\rfloor + 1\\)). The size of the grid is now \\(\\lceil \\frac{n+1}{2} \\rceil \\times n\\), which is an improvement over the first solution, and only twice the size of the theoretical lower bound.\nFinally, we can remove the first row because the vertical pairs it contributes by neighboring the second row are redundant as they are captured by the horizontal adjacency of the remaining rows. So the final size of the grid is \\(\\lfloor \\frac{n}{2} \\rfloor \\times n\\).\n\n\nCode\nLet us write a function to count the number of pairs that are adjacent to each other in a given grid.\n\nimport numpy as np\nimport numpy.typing as npt\nimport typing\n\ndef count_neighbors(a: npt.NDArray[np.int32], n: int) -> npt.NDArray[np.int32]:\n    \"\"\"Count the number of neighbors of each element in a.\n\n    Parameters\n    ----------\n    a : np.ndarray[np.int32]\n        The array containing the labels which are integers in [0,n-1].\n    n : int\n        The number of labels.\n\n    Returns\n    -------\n    np.ndarray[np.int32]\n        A symmetric nxn matrix where element i,j counts how many times\n        labels i and j appear horizontally or vertically next to each\n        other in a.\n    \"\"\"\n    # Expecting the values to be in [0,n) or an empty array\n    assert a.size==0 or a.max()<n and a.min()>=0\n\n    counts = np.zeros((n,n), dtype=np.int32)\n\n    for i in np.arange(a.shape[0]):\n        for j in np.arange(a.shape[1]):\n            if i>0:\n                counts[a[i,j],a[i-1,j]]+=1\n            if i<a.shape[0]-1: \n                counts[a[i,j],a[i+1,j]]+=1\n            if j>0:            \n                counts[a[i,j],a[i,j-1]]+=1\n            if j<a.shape[1]-1: \n                counts[a[i,j],a[i,j+1]]+=1\n    \n    # Function correctness check. There are a.shape[0]-1 pairs per row and a.shape[1]-1\n    # pairs per column. So the total number of pairs is\n    num_pairs = (a.shape[0]-1)*a.shape[1]+(a.shape[1]-1)*a.shape[0] if a.size>0 else 0\n    # (The size check is because an empty array can have a shape of (1,0) for example)\n    # Each pair increments two (symmetric) entries in the counts matrix. Therefore,\n    assert counts.sum() == 2*num_pairs\n    \n    return counts\n\ndef correct(counts: npt.NDArray[np.int32]) -> bool:\n    \"\"\"Check if the counts adjacency matrix satisfies the conditions of the problem.\n\n    Parameters\n    ----------\n    counts : np.ndarray[np.int32]\n        A symmetric nxn matrix where element i,j counts how many times\n        labels i and j appear horizontally or vertically next to each\n        other in a.\n\n    Returns\n    -------\n    bool\n        True if the counts matrix satisfies the conditions of the problem.\n    \"\"\"\n    # set diagonal to 1 if diagonal in the original matrix is 0\n    counts2=np.copy(counts)\n    np.fill_diagonal(counts2,np.diag(counts)==0) \n    # if all elements are nonzero, then the matrix is correct\n    return np.all(counts2) \n\nHere is how we can generate the grid using the players handshake algorithm.\n\ndef players_handshake_grid(n: int) -> npt.NDArray[np.int32]:\n    \n    if n==3: # degenerate case\n        # Same as general case below but don't skip first row\n        return np.array([np.roll(np.arange(n),i) for i in np.cumsum(range(n//2+1))]) \n    # General case\n    # Fill each row with the sequence 0,1,...,n-1 shifted by 1,3,6,10,15,...\n    return np.array([np.roll(np.arange(n),i) for i in np.cumsum(range(1,n//2+1))])      \n\nThe basic solution can be implemented as follows:\n\ndef basic_solution_grid(n: int) -> npt.NDArray[np.int32]:\n    a=np.empty((n,2*(n//2)),dtype=np.int32)\n    # fill each even column with the sequence 0,1,2,...,n-1\n    a[:,::2]=np.arange(n)[:,None] \n    # fill each odd column with the sequence 0,1,2,...,n-1 shifted by 1,2,...,n//2\n    a[:,1::2]=np.array([np.roll(np.arange(n),-i-1) for i in range(n//2)]).T\n    if n>=6:\n        a=a[:,3:] # remove first 3 columns\n    return a\n\nAn example of the grid generated by the players handshake algorithm for \\(n=7\\):\n\n# Players handshake with n=7\nn=7\na=players_handshake_grid(n)\ndisp_arrays_horiz((a,'grid'),(count_neighbors(a,n),'adjacency'))\nassert correct(count_neighbors(a,n))\n\n\\[\\begin{matrix}\\left[\\begin{matrix}6 & 0 & 1 & 2 & 3 & 4 & 5\\\\4 & 5 & 6 & 0 & 1 & 2 & 3\\\\1 & 2 & 3 & 4 & 5 & 6 & 0\\end{matrix}\\right]& & &\\left[\\begin{matrix}0 & 2 & 1 & 1 & 1 & 1 & 3\\\\2 & 0 & 3 & 1 & 1 & 1 & 1\\\\1 & 3 & 0 & 3 & 1 & 1 & 1\\\\1 & 1 & 3 & 0 & 2 & 1 & 1\\\\1 & 1 & 1 & 2 & 0 & 3 & 1\\\\1 & 1 & 1 & 1 & 3 & 0 & 2\\\\3 & 1 & 1 & 1 & 1 & 2 & 0\\end{matrix}\\right]\\\\\\text{grid}& & &\\text{adjacency}\\end{matrix}\\]\n\n\nThe adjacency matrix shows that each element is adjacent to each other element between 1 and 3 times, and never adjacent to itself (zero diagonal). Here is the grid generated by the basic solution for the same \\(n\\):\n\n# Basic solution with n=7\nn=7\na=basic_solution_grid(n)\ndisp_arrays_horiz((a,'grid'),(count_neighbors(a,n),'adjacency'))\nassert correct(count_neighbors(a,n))\n\n\\[\\begin{matrix}\\left[\\begin{matrix}2 & 0 & 3\\\\3 & 1 & 4\\\\4 & 2 & 5\\\\5 & 3 & 6\\\\6 & 4 & 0\\\\0 & 5 & 1\\\\1 & 6 & 2\\end{matrix}\\right]& & &\\left[\\begin{matrix}0 & 3 & 1 & 1 & 1 & 1 & 2\\\\3 & 0 & 2 & 1 & 1 & 1 & 1\\\\1 & 2 & 0 & 2 & 1 & 1 & 1\\\\1 & 1 & 2 & 0 & 3 & 1 & 1\\\\1 & 1 & 1 & 3 & 0 & 3 & 1\\\\1 & 1 & 1 & 1 & 3 & 0 & 3\\\\2 & 1 & 1 & 1 & 1 & 3 & 0\\end{matrix}\\right]\\\\\\text{grid}& & &\\text{adjacency}\\end{matrix}\\]\n\n\nWe can verify correctness for a any number of examples and also check if the grid is the tightest it can be:\n\ndef check_tightness(a: npt.NDArray[np.int32], n: int) -> bool:\n    \"\"\"Check if the solution is tight by removing the first and last row and column.\n\n    Parameters\n    ----------\n    a : np.ndarray[np.int32]\n        The solution.\n    n : number of labels.\n    Returns\n    -------\n    bool\n        True if none of the boundary rows or columns can be removed while maintaining\n        solution correctness.\n    \"\"\"\n    tight = True\n    if a.size>0 and correct(count_neighbors(a[1:,:],n)):\n        print(f'redundant first row for {n=}')\n        tight = False\n    if a.size>0 and correct(count_neighbors(a[:,1:],n)):\n        print(f'redundant first col for {n=}')  \n        tight = False\n    if a.size>0 and correct(count_neighbors(a[:-1,:],n)):\n        print(f'redundant last row for {n=}')\n        tight = False\n    if a.size>0 and correct(count_neighbors(a[:,:-1],n)):\n        print(f'redundant last col for {n=}')   \n        tight = False\n    return tight\n\ndef verify_method(n: int, method: typing.Callable[[int], npt.NDArray[np.int32]]) -> None:\n    \"\"\"Verify that the method returns a correct solution for n.\n\n    Parameters\n    ----------\n    n : int\n        The number of players.\n    method : Callable[[int], np.ndarray[np.int32]]\n        The method to be tested.\n    \"\"\"\n    a=method(n)\n    \n    assert correct(count_neighbors(a,n)), (n, a)\n\n    check_tightness(a,n)\n\nApplything this to the first 200 values of \\(n\\) using the players handshake algorithm, we get the following:\n\nfor n in range(200):\n    verify_method(n, players_handshake_grid)\n\nredundant first col for n=4\nredundant last col for n=4\n\n\nSimilarly, applying this to the first 200 values of \\(n\\) using the basic solution, we get the following:\n\nfor n in range(200):\n    verify_method(n, basic_solution_grid)\n\nredundant first row for n=2\nredundant first col for n=2\nredundant last row for n=2\nredundant last col for n=2\nredundant first row for n=4\nredundant first col for n=4\nredundant last row for n=4\nredundant first col for n=5\n\n\nIt is possible to show that the players handshake algorithm is not optimal in terms of grid size. For example, for \\(n=10\\), the algorithm generates a grid of size \\(5 \\times 10\\):\n\ndisp_arrays_horiz(\n    (players_handshake_grid(10), 'players handshake grid $n=10$'), \n    (count_neighbors(players_handshake_grid(10),10), 'adjacency matrix'))\nassert correct(count_neighbors(players_handshake_grid(10),10))\nassert check_tightness(players_handshake_grid(10),10)\n\n\\[\\begin{matrix}\\left[\\begin{matrix}9 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8\\\\7 & 8 & 9 & 0 & 1 & 2 & 3 & 4 & 5 & 6\\\\4 & 5 & 6 & 7 & 8 & 9 & 0 & 1 & 2 & 3\\\\0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9\\\\5 & 6 & 7 & 8 & 9 & 0 & 1 & 2 & 3 & 4\\end{matrix}\\right]& & &\\left[\\begin{matrix}0 & 5 & 1 & 1 & 1 & 2 & 1 & 1 & 1 & 4\\\\5 & 0 & 5 & 1 & 1 & 1 & 2 & 1 & 1 & 1\\\\1 & 5 & 0 & 5 & 1 & 1 & 1 & 2 & 1 & 1\\\\1 & 1 & 5 & 0 & 4 & 1 & 1 & 1 & 2 & 1\\\\1 & 1 & 1 & 4 & 0 & 4 & 1 & 1 & 1 & 2\\\\2 & 1 & 1 & 1 & 4 & 0 & 5 & 1 & 1 & 1\\\\1 & 2 & 1 & 1 & 1 & 5 & 0 & 4 & 1 & 1\\\\1 & 1 & 2 & 1 & 1 & 1 & 4 & 0 & 5 & 1\\\\1 & 1 & 1 & 2 & 1 & 1 & 1 & 5 & 0 & 4\\\\4 & 1 & 1 & 1 & 2 & 1 & 1 & 1 & 4 & 0\\end{matrix}\\right]\\\\\\text{players handshake grid $n=10$}& & &\\text{adjacency matrix}\\end{matrix}\\]\n\n\nBut here is a grid of size \\(5 \\times 8\\) that is also a solution:\n\n\n\\[\\begin{matrix}\\left[\\begin{matrix}1 & 2 & 3 & 4 & 5 & 6 & 7 & 8\\\\3 & 5 & 7 & 9 & 0 & 2 & 4 & 6\\\\7 & 0 & 4 & 8 & 1 & 5 & 9 & 2\\\\4 & 1 & 9 & 6 & 3 & 0 & 8 & 5\\\\9 & 3 & 8 & 2 & 7 & 1 & 6 & 0\\end{matrix}\\right]& & &\\left[\\begin{matrix}0 & 3 & 1 & 1 & 1 & 4 & 1 & 1 & 1 & 1\\\\3 & 0 & 1 & 3 & 1 & 1 & 1 & 1 & 1 & 1\\\\1 & 1 & 0 & 1 & 1 & 3 & 3 & 1 & 1 & 1\\\\1 & 3 & 1 & 0 & 1 & 1 & 1 & 3 & 1 & 1\\\\1 & 1 & 1 & 1 & 0 & 1 & 1 & 3 & 1 & 4\\\\4 & 1 & 3 & 1 & 1 & 0 & 1 & 1 & 1 & 1\\\\1 & 1 & 3 & 1 & 1 & 1 & 0 & 1 & 3 & 1\\\\1 & 1 & 1 & 3 & 3 & 1 & 1 & 0 & 1 & 1\\\\1 & 1 & 1 & 1 & 1 & 1 & 3 & 1 & 0 & 3\\\\1 & 1 & 1 & 1 & 4 & 1 & 1 & 1 & 3 & 0\\end{matrix}\\right]\\\\\\text{a solution grid for $n=10$}& & &\\text{adjacency matrix}\\end{matrix}\\]\n\n\nThe solutions I’ve shown here have a simple implementation and, especially the players handshake, is what I need for the original problem I was trying to solve: Distinct-color palette visualization. The other goal I had was to see how flexible and convenient it is to use the tools I used to create this post. I think I’ve achieved both goals. I hope you enjoyed reading this post as much as I enjoyed writing it. If you have any questions or suggestions, please leave a comment below. Thanks for reading!"
  },
  {
    "objectID": "posts/penny/penny.html",
    "href": "posts/penny/penny.html",
    "title": "Sub-Penny Precision Handling of Financial Data",
    "section": "",
    "text": "When dealing with market data that is obtained from any source, it is important to understand the precision of the price data for two reasons. The first is that sometimes, comparisons between prices are needed to assign a probability to certain events. For example, to predict whether a buy limit order will be filled, the low price of the next time interval needs to be compared to the limit price of the order. Further, the comparison may need to conclude if the limit price will be reached, indicating a probability of execution, or crossed (i.e., the low price unmistakably reached below the limit price) indicating definite execution (with some unrelated caveats). The second reason has to do with data representation which has implications on the amount of storage needed (both in memory and on disk) as well as processing time. The possible choices are usually 32-bit vs 64-bit and integer vs floating point.\nAlthough sub-penny quoting is not allowed by the SEC for orders above $1, it does not prevent trades from happening at any price. It is therefore expected to see open, high, low, close (OHLC) prices that are not multiples of $0.01. Bid and ask OHLC prices, however, are expected to be multiples of $0.01.\nIn this post, I will explore the precision characteristics of stock price data that was obtained from a market data vendor and derive suitable data representation for it.\n\n\nThe data comprises 1-minute intervals for 44 symbols over a period of 2,590 trading days (between 2012 and 2022). The total number of days from all stocks that have data is 94,438 (which is 83% of trading days due to missing data, e.g., stocks that were not in existence during the entire period). The total number of intervals (1-minute intervals, each containing price, bid and ask OHLC) is 626,123,940.\n\n\nLet us plot a histogram of the sub-penny values, with bin width of $0.00001 (1/1000th of a penny).\n\n\nCode\n# ohlc has shape (n_days, 3, 4): (n_days, [price,bid,ask], [open,high,low,close])\nfracs = np.modf(ohlc*100.0)[0]/100.0 # keep only sub-cent fractions\n# can also be done like this:\n# _,w = np.modf(ohlc*100.0)\n# fracs = ohlc - w/100.0\nsamples, step = np.linspace(start=0,stop=.01,num=1001,endpoint=True, retstep=True)\nbins=np.concatenate((samples-step/2, [samples[-1]+step/2]))\n# these bins have a .0001 width (x±.00005 where x is any multiple of .0001 between 0 and .01)\n# bins can also be set to just the value 1001 (which causes them to be computed automatically)\n\nfig=plt.figure(figsize=(10,6))\n\ndef hist_plot(ax, arr):\n    ax.hist(arr.flatten(), bins=bins, histtype='step', linewidth=.5, log=True) \n    # start below 1.0 so even a count of 1 shows up; show all powers\n    ax.set_ylim(bottom=0.1)\n    ax.yaxis.set_major_locator(matplotlib.ticker.LogLocator(numticks=20))\n    ax.grid(axis='y')\n    # set x tickmarks every .0001\n    ax.xaxis.set_minor_locator(matplotlib.ticker.MultipleLocator(.0001))\n    ax.xaxis.set_major_locator(matplotlib.ticker.MultipleLocator(.001))\n\n# price histogram\nax=fig.add_subplot(211)\nhist_plot(ax, fracs[:,0,:])\nax.set_title('Price histogram')\n\n# bid/ask histogram\nax=fig.add_subplot(212)\nhist_plot(ax, fracs[:,1:,:])\nax.set_title('Bid/ask histogram')\n\nplt.tight_layout()\n\n\n\n\n\nTwo observations can be made from the histograms. First, the prices occur (even if rarely sometimes) at 0.0001 intervals (1/100th of a penny). We know this because the histogram has 10 times more bins and all but those 101 are empty. Second, the bid/ask prices, as expected, are multiples of $0.01. We also see that the bin surrounding $0.01 is nonempty which means that the prices may have some numeric precision fluctuation around their expected discrete values. But this is likely introduced in the process of extracting the sub-penny fractions. To verify that, we can compare the original data to its rounded (to 4 decimals for price and to 2 decimals for bid/ask) version:\n\n# price\nprint(np.array_equal(ohlc[:,0,:], np.round(ohlc[:,0,:], decimals=4)))\n# bid/ask\nprint(np.array_equal(ohlc[:,1:,:], np.round(ohlc[:,1:,:], decimals=2)))\n\nTrue\nTrue\n\n\nLet’s talk about data representation. The data source is 64-bit floating point and as such, np.float64 numpy arrays will work fine. When comparing two values for reach or cross and strictly cross (from above), the <= and < operators can used respectively. Had there been noise due to numeric precision, the following safer tests (which also work when there is no noise) are guaranteed to work given what we know about the multiple of $0.0001 price precision of this data:\n\na reaches or crosses b from above: a < b + 0.00005\na strictly crosses b from above: a < b - 0.00005\n\nIt is not possible, however, to preserve the inherent precision of the data by using 32-bit floating point without making strong assumptions about the maximum price. The following example illustrates this:\n\nprint(np.float32(1026.4101)==np.float32(1026.4102))\nprint(np.float32(1026.41)==np.float32(1026.41005))\n\nTrue\nTrue\n\n\n\n\n32-bit unsigned integer is a viable option if we store the prices multiplied by 10000. Comparisons in this case are also straightforward using the comparison operators. The only limitation is that the maximum representable price is $429,496.7295. This is not a problem for most stocks with the exception of BRK.A.\n\n\n\nConclusions\n\nThe market price data can be sub-penny with a granularity of $0.0001 (1/100th of a penny).\nThe bid/ask prices are always multiples of $0.01 (when they are above $1).\nThe price data is 64-bit floating point and can be represented as such.\nRepresenting the price data as 32-bit floating point is not possible losslessly without making strong assumptions about the maximum price.\n32-bit unsigned integer is lossless and has a much higher representable price ceiling than 32-bit floating point."
  }
]