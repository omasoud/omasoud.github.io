[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Random thoughts, problems, projects. It helps me refresh my memory and hopefully helps others."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Idea Factory",
    "section": "",
    "text": "Sub-Penny Precision Handling of Financial Data\n\n\n\n\n\n\n\ncode\n\n\nanalysis\n\n\nfinance\n\n\n\n\nAnalysis of financial data sub-penny precision and how to deal with it.\n\n\n\n\n\n\nDec 1, 2022\n\n\nO. Masoud\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/penny/penny.html",
    "href": "posts/penny/penny.html",
    "title": "Sub-Penny Precision Handling of Financial Data",
    "section": "",
    "text": "When dealing with market data that is obtained from any source, it is important to understand the precision of the price data for two reasons. The first is that sometimes, comparisons between prices are needed to assign a probability to certain events. For example, to predict whether a buy limit order will be filled, the low price of the next time interval needs to be compared to the limit price of the order. Further, the comparison may need to conclude if the limit price will be reached, indicating a probability of execution, or crossed (i.e., the low price unmistakably reached below the limit price) indicating definite execution (with some unrelated caveats). The second reason has to do with data representation which has implications on the amount of storage needed (both in memory and on disk) as well as processing time. The possible choices are usually 32-bit vs 64-bit and integer vs floating point.\nAlthough sub-penny quoting is not allowed by the SEC for orders above $1, it does not prevent trades from happening at any price. It is therefore expected to see open, high, low, close (OHLC) prices that are not multiples of $0.01. Bid and ask OHLC prices, however, are expected to be multiples of $0.01.\nIn this post, I will explore the precision characteristics of stock price data that was obtained from a market data vendor and derive suitable data representation for it.\n\n\nThe data comprises 1-minute intervals for 44 symbols over a period of 2,590 trading days (between 2012 and 2022). The total number of days from all stocks that have data is 94,438 (which is 83% of trading days due to missing data, e.g., stocks that were not in existence during the entire period). The total number of intervals (1-minute intervals, each containing price, bid and ask OHLC) is 626,123,940.\n\n\nLet us plot a histogram of the sub-penny values, with bin width of $0.00001 (1/1000th of a penny).\n\n\nCode\n# ohlc has shape (n_days, 3, 4): (n_days, [price,bid,ask], [open,high,low,close])\nfracs = np.modf(ohlc*100.0)[0]/100.0 # keep only sub-cent fractions\n# can also be done like this:\n# _,w = np.modf(ohlc*100.0)\n# fracs = ohlc - w/100.0\nsamples, step = np.linspace(start=0,stop=.01,num=1001,endpoint=True, retstep=True)\nbins=np.concatenate((samples-step/2, [samples[-1]+step/2]))\n# these bins have a .0001 width (x±.00005 where x is any multiple of .0001 between 0 and .01)\n# bins can also be set to just the value 1001 (which causes them to be computed automatically)\n\nfig=plt.figure(figsize=(10,6))\n\ndef hist_plot(ax, arr):\n    ax.hist(arr.flatten(), bins=bins, histtype='step', linewidth=.5, log=True) \n    # start below 1.0 so even a count of 1 shows up; show all powers\n    ax.set_ylim(bottom=0.1)\n    ax.yaxis.set_major_locator(matplotlib.ticker.LogLocator(numticks=20))\n    ax.grid(axis='y')\n    # set x tickmarks every .0001\n    ax.xaxis.set_minor_locator(matplotlib.ticker.MultipleLocator(.0001))\n    ax.xaxis.set_major_locator(matplotlib.ticker.MultipleLocator(.001))\n\n# price histogram\nax=fig.add_subplot(211)\nhist_plot(ax, fracs[:,0,:])\nax.set_title('Price histogram')\n\n# bid/ask histogram\nax=fig.add_subplot(212)\nhist_plot(ax, fracs[:,1:,:])\nax.set_title('Bid/ask histogram')\n\nplt.tight_layout()\n\n\n\n\n\nTwo observations can be made from the histograms. First, the prices occur (even if rarely sometimes) at 0.0001 intervals (1/100th of a penny). We know this because the histogram has 10 times more bins and all but those 101 are empty. Second, the bid/ask prices, as expected, are multiples of $0.01. We also see that the bin surrounding $0.01 is nonempty which means that the prices may have some numeric precision fluctuation around their expected discrete values. But this is likely introduced in the process of extracting the sub-penny fractions. To verify that, we can compare the original data to its rounded (to 4 decimals for price and to 2 decimals for bid/ask) version:\n\n# price\nprint(np.array_equal(ohlc[:,0,:], np.round(ohlc[:,0,:], decimals=4)))\n# bid/ask\nprint(np.array_equal(ohlc[:,1:,:], np.round(ohlc[:,1:,:], decimals=2)))\n\nTrue\nTrue\n\n\nLet’s talk about data representation. The data source is 64-bit floating point and as such, np.float64 numpy arrays will work fine. When comparing two values for reach or cross and strictly cross (from above), the <= and < operators can used respectively. Had there been noise due to numeric precision, the following safer tests (which also work when there is no noise) are guaranteed to work given what we know about the multiple of $0.0001 price precision of this data:\n\na reaches or crosses b from above: a < b + 0.00005\na strictly crosses b from above: a < b - 0.00005\n\nIt is not possible, however, to preserve the inherent precision of the data by using 32-bit floating point without making strong assumptions about the maximum price. The following example illustrates this:\n\nprint(np.float32(1026.4101)==np.float32(1026.4102))\nprint(np.float32(1026.41)==np.float32(1026.41005))\n\nTrue\nTrue\n\n\n\n\n32-bit unsigned integer is a viable option if we store the prices multiplied by 10000. Comparisons in this case are also straightforward using the comparison operators. The only limitation is that the maximum representable price is $429,496.7295. This is not a problem for most stocks with the exception of BRK.A.\n\n\n\nConclusions\n\nThe market price data can be sub-penny with a granularity of $0.0001 (1/100th of a penny).\nThe bid/ask prices are always multiples of $0.01 (when they are above $1).\nThe price data is 64-bit floating point and can be represented as such.\nRepresenting the price data as 32-bit floating point is not possible losslessly without making strong assumptions about the maximum price.\n32-bit unsigned integer is lossless and has a much higher representable price ceiling than 32-bit floating point."
  }
]