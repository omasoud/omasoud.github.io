<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="O. Masoud">
<meta name="dcterms.date" content="2023-01-08">
<meta name="description" content="From a list of labels, construct a grid where each two labels are neighbors at least once, and no label is a neighbor of itself.">

<title>blog - All-Pairs Grid Neighbors</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js" integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">blog</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/omasoud"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">All-Pairs Grid Neighbors</h1>
                  <div>
        <div class="description">
          From a list of labels, construct a grid where each two labels are neighbors at least once, and no label is a neighbor of itself.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">code</div>
                <div class="quarto-category">python</div>
                <div class="quarto-category">graph theory</div>
                <div class="quarto-category">numpy</div>
                <div class="quarto-category">permutations</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>O. Masoud </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 8, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>I came across this problem while working on a method to generate a color palette consisting of <span class="math inline">\(n\)</span>, where all colors are visibly different from one another. I wanted compact way of visualizing the palette to see what colors are too close to each other, and which ones are far enough apart. One way would be to list all <span class="math inline">\(\frac{n*(n-1)}{2}\)</span> pairs of colors, but that would be a long one-dimensional list. What I wanted instead is to visualize the colors in a grid that is guaranteed to have each pair of colors present somewhere as neighbors, and where no two neighbors are the same color. The second condition is of course necessary since we are trying to create a tool for comparing different colors by showing them as adjacent cells, and hence we want to make sure we are not repeating the color in two adjacent cells.</p>
<section id="problem-statement" class="level4">
<h4 class="anchored" data-anchor-id="problem-statement">Problem Statement</h4>
<!-- <span style="display:inline-block;margin-left:2em;"> -->
<p>The problem we are trying to solve can be stated as follows:</p>
<div class="alert alert-block alert-warning">
Given an integer <span class="math inline">\(n\)</span>, construct a grid where each cell contains an integers in <span class="math inline">\([0, n-1]\)</span>, such that,
<ol style="list-style:lower-roman;line-height:1.5;">
<li>
every possible pair of integers <span class="math inline">\((i,j)\)</span>, <span class="math inline">\(i \ne j\)</span>, <span class="math inline">\(i\)</span>, <span class="math inline">\(j\)</span> in <span class="math inline">\([0, n-1]\)</span> is present at least once as two horizontally or vertically adjacent cells in the grid, and,
</li>
<li>
<!-- style="line-height:.5;"> -->
no two horizontally or vertically adjacent cells contain the same integer.
</li>
</ol>
</div>
<p>Note that <span class="math inline">\((i,j)\)</span> is present <span class="math inline">\(\iff\)</span> <span class="math inline">\((j,i)\)</span> is also present, and hence they are essentially the same pair.</p>
<p>Ideally, the grid should be as small as possible. But let us not worry about that for now.</p>
<p>We know the grid cannot contain less than <span class="math inline">\(n\)</span> cells, otherwise we would be missing some numbers; but that is too low of lower bound on the grid size. Let us see if we can find a lower bound higher than this.</p>
<p>A grid of size <span class="math inline">\(r \times c\)</span> can represent at most <span class="math inline">\((r-1)c + (c-1)r\)</span> pairs because that is the number of internal edges, each of which shared by two cells (and so, excluding edges on the outer border).</p>
<p>Further, we only need to consider square grids to find a lower bound. This follows from the claim that of all grid sizes containing the same number of internal edges, the smallest grid size, if size is measured by the number of cells, must have <span class="math inline">\(r=c\)</span>. The proof is as follows. If we call the number of internal edges <span class="math inline">\(e\)</span>, where <span class="math inline">\(e = (r-1)c + (c-1)r\)</span> and the grid size <span class="math inline">\(s\)</span>, where <span class="math inline">\(s = rc\)</span>, then,</p>
<div class="cell" data-execution_count="27">
<div class="cell-output cell-output-display">
<p><span class="math display">\[c = \frac{e + r}{2 r - 1} \tag{1} \]</span></p>
</div>
<div class="cell-output cell-output-display">
<p><span class="math display">\[s = c r = \frac{r \left(e + r\right)}{2 r - 1} \tag{2} \]</span></p>
</div>
</div>
<div class="cell" data-execution_count="28">
<div class="cell-output cell-output-display">
<p><span class="math display">\[ \frac{\partial s}{\partial r} =\frac{- e + 2 r^{2} - 2 r}{\left(2 r - 1\right)^{2}} \tag{3} \]</span></p>
</div>
</div>
<div class="cell" data-execution_count="29">
<div class="cell-output cell-output-display">
<p>Setting <span class="math inline">\(\frac{\partial s}{\partial r}=0\)</span> we get:</p>
</div>
<div class="cell-output cell-output-display">
<p><span class="math display">\[r_{min} = \frac{\sqrt{2 e + 1}}{2} + \frac{1}{2} \tag{4} \]</span></p>
</div>
</div>
<div class="cell" data-execution_count="30">
<div class="cell-output cell-output-display">
<p>Subsituting <span class="math inline">\(r_{min}\)</span> from <span class="math inline">\((4)\)</span> into <span class="math inline">\((1)\)</span> we get:</p>
</div>
<div class="cell-output cell-output-display">
<p><span class="math display">\[c_{min} = \frac{2 e + \sqrt{2 e + 1} + 1}{2 \sqrt{2 e + 1}} = \frac{\sqrt{2 e + 1}}{2} + \frac{1}{2} = r_{min} \tag{5} \]</span></p>
</div>
</div>
<div class="cell" data-execution_count="31">
<div class="cell-output cell-output-display">
<p>Hence, the square grid is an extremum. Note that the second derivative of <span class="math inline">\(s\)</span> is:</p>
</div>
<div class="cell-output cell-output-display">
<p><span class="math display">\[ \frac{\partial^2 s}{\partial r^2}=\frac{2 \cdot \left(2 e + 1\right)}{\left(2 r - 1\right)^{3}} \tag{6} \]</span></p>
</div>
</div>
<div class="cell" data-execution_count="32">
<div class="cell-output cell-output-display">
<p>Subsituting <span class="math inline">\(r_{min}\)</span> from <span class="math inline">\((4)\)</span> into <span class="math inline">\((6)\)</span> we get:</p>
</div>
<div class="cell-output cell-output-display">
<p><span class="math display">\[\frac{\partial^2 s}{\partial r^2}(r_{min})=\frac{2}{\sqrt{2 e + 1}} \gt 0 \tag{7} \]</span></p>
</div>
</div>
<p>which is a positive constant and therefore, the square grid with <span class="math inline">\(r = c = r_{min} = c_{min}\)</span> is where the grid size, <span class="math inline">\(s\)</span>, is minimum.</p>
<p>By setting <span class="math inline">\(e = \frac{n(n-1)}{2}\)</span>, which is the total number of pairs, and substituting in <span class="math inline">\((4)\)</span>, we can establish the a lower bound on the dimension <span class="math inline">\(d\)</span>, (<span class="math inline">\(r=c=d\)</span>), of the grid:</p>
<div class="cell" data-execution_count="33">
<div class="cell-output cell-output-display">
<p><span class="math display">\[ d \ge \frac{\sqrt{n \left(n - 1\right) + 1}}{2} + \frac{1}{2} \tag{8} \]</span></p>
</div>
</div>
<div class="cell" data-execution_count="34">
<div class="cell-output cell-output-display">
<p>As a fraction of <span class="math inline">\(n\)</span>, this converges to:</p>
</div>
<div class="cell-output cell-output-display">
<p><span class="math display">\[ \lim_{n \to \infty}\left(\frac{\frac{\sqrt{n \left(n - 1\right) + 1}}{2} + \frac{1}{2}}{n}\right)=\frac{1}{2} \tag{9} \]</span></p>
</div>
</div>
<p>Therefore, the solution cannot be achieved with a grid size smaller than <span class="math inline">\(\frac{n}{2} \times \frac{n}{2}\)</span>. The optimum solution may of course be higher than this theoretical lower bound.</p>
</section>
<section id="solutions" class="level4">
<h4 class="anchored" data-anchor-id="solutions">Solutions</h4>
<p>I could not find much information about this problem except for a relevant <a href="https://stackoverflow.com/q/18126570/5659969">stackoverflow question</a> that did not seem to have received much attention. A solution among the answers proposed to start by placing a number in the corner and build the grid by adding numbers iteratively towards satisfying the constraints. This could be an interesting approach but I have not tried it yet.</p>
<p><strong>A possible basic solution</strong> is to take the full list of pairs and arrange them in a grid. For example, the first row could contain the sequence of the following <span class="math inline">\(n-1\)</span> pairs, which when arranged this way, will not have any number adjacent to itself: <span class="math display">\[(\phantom{nnn}0,\phantom{nnn}1), (\phantom{nnn}0,2), (\phantom{nnn}0,3), \dotsc, (\phantom{nnn}0,n-2), (\phantom{nnn}0,n-1)\]</span> Following this pattern, whose odd columns resemble a <a href="https://en.wikipedia.org/wiki/Toeplitz_matrix">Toeplitz matrix</a>, the remaining rows will contain <span class="math display">\[(\phantom{nnn}1,\phantom{nnn}2), (\phantom{nnn}1,3), (\phantom{nnn}1,4), \dotsc, (\phantom{nnn}1,n-1), (\phantom{nnn}1,\phantom{nnn}0)\]</span> <span class="math display">\[(\phantom{nnn}2,\phantom{nnn}3), (\phantom{nnn}2,4), (\phantom{nnn}2,5), \dotsc, (\phantom{nnn}2,\phantom{nnn}0), (\phantom{nnn}2,\phantom{nnn}1)\]</span> <span class="math display">\[ \dotsc \]</span> <span class="math display">\[(n-2,n-1), (n-2,0), (n-2,1), \dotsc, (n-2,n-4), (n-2,n-3)\]</span> <span class="math display">\[(n-1,\phantom{nnn}0), (n-1,1), (n-1,2), \dotsc, (n-1,n-3), (n-1,n-2)\]</span></p>
<p>Since the <span class="math inline">\(i^{th}\)</span> row contains all pairs that begin with <span class="math inline">\(i\)</span>, the <span class="math inline">\(n\)</span> rows of the grid contain all possible pairs. In addition, because each column always contains an increasing sequence (modulo <span class="math inline">\(n\)</span>) of numbers, there are no self-adjacent numbers vertically. Therefore, the grid satisfies the two conditions we wanted. The size of this grid is <span class="math inline">\(n \times 2(n-1)\)</span>.</p>
<p>Looking at this arrangement, and given that a pair <span class="math inline">\((a,b)\)</span> is equivalent to a pair <span class="math inline">\((b,a)\)</span>, it is easy to observe that the pairs represented by last two columns are equivalent to the pairs represented by the first two columns, shifted cyclically down by one row. The same is true for the third and fourth to last columns, which are equivalent to the third and fourth columns shifted cyclically down by two rows, and so on. This means that we can reduce the size of the grid by about half, by only considering the first <span class="math inline">\(\lfloor \frac{p+1}{2} \rfloor\)</span> pairs, where <span class="math inline">\(p=n-1\)</span> is the number of pairs per row. Hence, the size of the grid can now be reduced to <span class="math inline">\(n \times 2\lfloor \frac{n}{2} \rfloor\)</span>.</p>
<p>It can also be shown that the first three columns can be removed if <span class="math inline">\(n&gt;=6\)</span>. This is because the first two columns capture only <span class="math inline">\(k\)</span> and <span class="math inline">\(k+1 \pmod n\)</span> pairs, which are abundantly represented throughout the grid. Additionally, the pairs generated by the 3rd and 4th columns are the same pairs generated by the 4th and 5th. The size of the grid can now be reduced to <span class="math inline">\(n \times (2\lfloor \frac{n}{2} \rfloor - 3)\)</span> if <span class="math inline">\(n&gt;=6\)</span>.</p>
<p>Another possible solution is as follows. We will keep horizontal adjacency constant throughout and focus on vertical adjacency. We start with the sequence <span class="math inline">\(0,1,2,\dotsc,n-1\)</span> as the first row. Then, in the second row, place a (cyclically) shifted by <span class="math inline">\(1\)</span> version of the first row: <span class="math inline">\(n-1,0,1,2,\dotsc,n-2\)</span>. With this, each number is now below the number that is next to it in the sequence (e.g., <span class="math inline">\(0\)</span> is under <span class="math inline">\(1\)</span>). In the third row, place a (cyclically) shifted by <span class="math inline">\(2\)</span> version of the second row (i.e., by <span class="math inline">\(3\)</span> of the first row): <span class="math inline">\(n-3,n-2,n-1,0,1,\dotsc,n-4\)</span>. Now <span class="math inline">\(0\)</span> is under <span class="math inline">\(2\)</span>. This way, with every new row, each number gets to be vertically adjacent to a new number (one number higher than what it was adjacent to in the previous row). The amount of shift in terms of the first row will be <span class="math inline">\(1,3,6,10,15,\dotsc\)</span>. Essentially, we have the sequence of all the numbers walking past the sequence of all the numbers and therefore each number gets to meet each other number, just like when the players of two teams line up and walk past each other to shake hands. Hence, we will call this solution the <strong>players handshake algorithm</strong>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="handshake-still.png" class="img-fluid figure-img" data-alt="handshake.gif" width="280"></p>
<p></p><figcaption class="figure-caption">Click Me</figcaption><p></p>
</figure>
</div>
<!-- <figure>
    <img width="280" src="handshake-still.png" data-alt="handshake.gif" /> 
    <figcaption>Click Me!</figcaption>
</figure> -->
<div class="cell" data-vscode="{&quot;languageId&quot;:&quot;javascript&quot;}" data-execution_count="37">
<div class="cell-output cell-output-display">
<script type="application/javascript">

(function ($) {

  // Change the image to .gif when clicked and vice versa.
  $('figure').on('click', function () {
    // Debugging
    // $('img', this).each(function () {  
    //  $.each(this.attributes, function () {
    //      if (this.specified) {
    //          console.log(this.name, this.value);
    //      }
    //  });
    // });
    // console.info('debug: ' + $(this).children('img'))
    // console.info('debug: ' + $(this).children('img').attr('src'))
    // console.info('debug: ' + $(this).children('img').attr('data-alt'))
    // console.info('debug: ' + $(this).children('img').attr('alt'))

    var $this = $(this),
      //$index = $this.index(),
      $img = $('img', this), // $('img',this) is the same as $(this).find('img') to go as deep as needed and not just direct children
      $imgSrc = $img.attr('src'),
      $imgAlt = $img.attr('data-alt'),
      $imgExt = $imgAlt.split('.');
    // Debugging
    // console.info('src: ' + $imgSrc);
    // console.info('data-alt: ' + $imgAlt);
    // console.info('alt: ' + $img.data('alt')) // data('alt') is always the original value of data-alt
    // console.info('ext: ' + $imgExt)

    // swap the src and data-alt attributes
    if ($imgExt[$imgExt.length - 1] === 'gif') {
      console.info('gif')
      $img.attr('src', $imgAlt).attr('data-alt', $imgSrc);
    } else {
      console.info('png')
      $img.attr('src', $imgAlt).attr('data-alt', $imgSrc);
    }

    // Add play class to help with the styling.
    //$this.toggleClass('play');

  });

})(jQuery);


</script>
</div>
</div>
<p>This pattern needs to stop before a number becomes vertically adjacent to itself, which would take <span class="math inline">\(n\)</span> rows. But we can stop earlier. To see this, let us take a look at the full matrix of the grid with <span class="math inline">\(n=5\)</span>,</p>
<p><span class="math display">\[ \begin{bmatrix} 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 \\ 4 &amp; 0 &amp; 1 &amp; 2 &amp; 3 \\ 2 &amp; 3 &amp; 4 &amp; 0 &amp; 1 \\ 4 &amp; 0 &amp; 1 &amp; 2 &amp; 3 \\ 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 \end{bmatrix} \]</span></p>
<p>and with <span class="math inline">\(n=6\)</span>,</p>
<p><span class="math display">\[ \begin{bmatrix} 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 \\ 5 &amp; 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 \\ 3 &amp; 4 &amp; 5 &amp; 0 &amp; 1 &amp; 2 \\ 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 \\ 2 &amp; 3 &amp; 4 &amp; 5 &amp; 0 &amp; 1 \\ 3 &amp; 4 &amp; 5 &amp; 0 &amp; 1 &amp; 2 \end{bmatrix} \]</span></p>
<p>In the second row of these matrices, we established <span class="math inline">\(n\)</span> new vertical pairs, and in each subsequent row, another set of <span class="math inline">\(n\)</span> new pairs are added. Since the total number of possible pairs is <span class="math inline">\(\frac{n(n-1)}{2}\)</span>, we should be able to stop after <span class="math inline">\(\frac{n-1}{2}\)</span> rows. It can be seen in the above two matrices that the first two rows and the last two rows contain the same vertical pairs, and so on. When <span class="math inline">\(n=5\)</span>, we need 3 rows to get all the pairs, and when <span class="math inline">\(n=6\)</span>, we need 4 rows to get all the pairs. Hence, the number of rows needed is <span class="math inline">\(\lceil \frac{n+1}{2} \rceil\)</span> (or <span class="math inline">\(\lfloor \frac{n}{2} \rfloor + 1\)</span>). The size of the grid is now <span class="math inline">\(\lceil \frac{n+1}{2} \rceil \times n\)</span>, which is an improvement over the first solution, and only twice the size of the theoretical lower bound.</p>
<p>Finally, we can remove the first row because the vertical pairs it contributes by neighboring the second row are redundant as they are captured by the horizontal adjacency of the remaining rows. So the final size of the grid is <span class="math inline">\(\lfloor \frac{n}{2} \rfloor \times n\)</span>.</p>
</section>
<section id="code" class="level4">
<h4 class="anchored" data-anchor-id="code">Code</h4>
<p>Let us write a function to count the number of pairs that are adjacent to each other in a given grid.</p>
<div class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy.typing <span class="im">as</span> npt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> typing</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_neighbors(a: npt.NDArray[np.int32], n: <span class="bu">int</span>) <span class="op">-&gt;</span> npt.NDArray[np.int32]:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Count the number of neighbors of each element in a.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">    a : np.ndarray[np.int32]</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">        The array containing the labels which are integers in [0,n-1].</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">    n : int</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">        The number of labels.</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co">    np.ndarray[np.int32]</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co">        A symmetric nxn matrix where element i,j counts how many times</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co">        labels i and j appear horizontally or vertically next to each</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co">        other in a.</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Expecting the values to be in [0,n) or an empty array</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> a.size<span class="op">==</span><span class="dv">0</span> <span class="kw">or</span> a.<span class="bu">max</span>()<span class="op">&lt;</span>n <span class="kw">and</span> a.<span class="bu">min</span>()<span class="op">&gt;=</span><span class="dv">0</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    counts <span class="op">=</span> np.zeros((n,n), dtype<span class="op">=</span>np.int32)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> np.arange(a.shape[<span class="dv">0</span>]):</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> np.arange(a.shape[<span class="dv">1</span>]):</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i<span class="op">&gt;</span><span class="dv">0</span>:</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>                counts[a[i,j],a[i<span class="op">-</span><span class="dv">1</span>,j]]<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i<span class="op">&lt;</span>a.shape[<span class="dv">0</span>]<span class="op">-</span><span class="dv">1</span>: </span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>                counts[a[i,j],a[i<span class="op">+</span><span class="dv">1</span>,j]]<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> j<span class="op">&gt;</span><span class="dv">0</span>:            </span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>                counts[a[i,j],a[i,j<span class="op">-</span><span class="dv">1</span>]]<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> j<span class="op">&lt;</span>a.shape[<span class="dv">1</span>]<span class="op">-</span><span class="dv">1</span>: </span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>                counts[a[i,j],a[i,j<span class="op">+</span><span class="dv">1</span>]]<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Function correctness check. There are a.shape[0]-1 pairs per row and a.shape[1]-1</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># pairs per column. So the total number of pairs is</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    num_pairs <span class="op">=</span> (a.shape[<span class="dv">0</span>]<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>a.shape[<span class="dv">1</span>]<span class="op">+</span>(a.shape[<span class="dv">1</span>]<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>a.shape[<span class="dv">0</span>] <span class="cf">if</span> a.size<span class="op">&gt;</span><span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (The size check is because an empty array can have a shape of (1,0) for example)</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Each pair increments two (symmetric) entries in the counts matrix. Therefore,</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> counts.<span class="bu">sum</span>() <span class="op">==</span> <span class="dv">2</span><span class="op">*</span>num_pairs</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> counts</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> correct(counts: npt.NDArray[np.int32]) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Check if the counts adjacency matrix satisfies the conditions of the problem.</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a><span class="co">    counts : np.ndarray[np.int32]</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="co">        A symmetric nxn matrix where element i,j counts how many times</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="co">        labels i and j appear horizontally or vertically next to each</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a><span class="co">        other in a.</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a><span class="co">    bool</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a><span class="co">        True if the counts matrix satisfies the conditions of the problem.</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    <span class="co"># set diagonal to 1 if diagonal in the original matrix is 0</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    counts2<span class="op">=</span>np.copy(counts)</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    np.fill_diagonal(counts2,np.diag(counts)<span class="op">==</span><span class="dv">0</span>) </span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>    <span class="co"># if all elements are nonzero, then the matrix is correct</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">all</span>(counts2) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here is how we can generate the grid using the players handshake algorithm.</p>
<div class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> players_handshake_grid(n: <span class="bu">int</span>) <span class="op">-&gt;</span> npt.NDArray[np.int32]:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n<span class="op">==</span><span class="dv">3</span>: <span class="co"># degenerate case</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Same as general case below but don't skip first row</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.array([np.roll(np.arange(n),i) <span class="cf">for</span> i <span class="kw">in</span> np.cumsum(<span class="bu">range</span>(n<span class="op">//</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span>))]) </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># General case</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill each row with the sequence 0,1,...,n-1 shifted by 1,3,6,10,15,...</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([np.roll(np.arange(n),i) <span class="cf">for</span> i <span class="kw">in</span> np.cumsum(<span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">//</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span>))])      </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The basic solution can be implemented as follows:</p>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> basic_solution_grid(n: <span class="bu">int</span>) <span class="op">-&gt;</span> npt.NDArray[np.int32]:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    a<span class="op">=</span>np.empty((n,<span class="dv">2</span><span class="op">*</span>(n<span class="op">//</span><span class="dv">2</span>)),dtype<span class="op">=</span>np.int32)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># fill each even column with the sequence 0,1,2,...,n-1</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    a[:,::<span class="dv">2</span>]<span class="op">=</span>np.arange(n)[:,<span class="va">None</span>] </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># fill each odd column with the sequence 0,1,2,...,n-1 shifted by 1,2,...,n//2</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    a[:,<span class="dv">1</span>::<span class="dv">2</span>]<span class="op">=</span>np.array([np.roll(np.arange(n),<span class="op">-</span>i<span class="op">-</span><span class="dv">1</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">//</span><span class="dv">2</span>)]).T</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n<span class="op">&gt;=</span><span class="dv">6</span>:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        a<span class="op">=</span>a[:,<span class="dv">3</span>:] <span class="co"># remove first 3 columns</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>An example of the grid generated by the players handshake algorithm for <span class="math inline">\(n=7\)</span>:</p>
<div class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Players handshake with n=7</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span><span class="dv">7</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span>players_handshake_grid(n)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>disp_arrays_horiz((a,<span class="st">'grid'</span>),(count_neighbors(a,n),<span class="st">'adjacency'</span>))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> correct(count_neighbors(a,n))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><span class="math display">\[\begin{matrix}\left[\begin{matrix}6 &amp; 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\\4 &amp; 5 &amp; 6 &amp; 0 &amp; 1 &amp; 2 &amp; 3\\1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 0\end{matrix}\right]&amp; &amp; &amp;\left[\begin{matrix}0 &amp; 2 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 3\\2 &amp; 0 &amp; 3 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\1 &amp; 3 &amp; 0 &amp; 3 &amp; 1 &amp; 1 &amp; 1\\1 &amp; 1 &amp; 3 &amp; 0 &amp; 2 &amp; 1 &amp; 1\\1 &amp; 1 &amp; 1 &amp; 2 &amp; 0 &amp; 3 &amp; 1\\1 &amp; 1 &amp; 1 &amp; 1 &amp; 3 &amp; 0 &amp; 2\\3 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 0\end{matrix}\right]\\\text{grid}&amp; &amp; &amp;\text{adjacency}\end{matrix}\]</span></p>
</div>
</div>
<p>The adjacency matrix shows that each element is adjacent to each other element between 1 and 3 times, and never adjacent to itself (zero diagonal). Here is the grid generated by the basic solution for the same <span class="math inline">\(n\)</span>:</p>
<div class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Basic solution with n=7</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span><span class="dv">7</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span>basic_solution_grid(n)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>disp_arrays_horiz((a,<span class="st">'grid'</span>),(count_neighbors(a,n),<span class="st">'adjacency'</span>))</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> correct(count_neighbors(a,n))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><span class="math display">\[\begin{matrix}\left[\begin{matrix}2 &amp; 0 &amp; 3\\3 &amp; 1 &amp; 4\\4 &amp; 2 &amp; 5\\5 &amp; 3 &amp; 6\\6 &amp; 4 &amp; 0\\0 &amp; 5 &amp; 1\\1 &amp; 6 &amp; 2\end{matrix}\right]&amp; &amp; &amp;\left[\begin{matrix}0 &amp; 3 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 2\\3 &amp; 0 &amp; 2 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\1 &amp; 2 &amp; 0 &amp; 2 &amp; 1 &amp; 1 &amp; 1\\1 &amp; 1 &amp; 2 &amp; 0 &amp; 3 &amp; 1 &amp; 1\\1 &amp; 1 &amp; 1 &amp; 3 &amp; 0 &amp; 3 &amp; 1\\1 &amp; 1 &amp; 1 &amp; 1 &amp; 3 &amp; 0 &amp; 3\\2 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 3 &amp; 0\end{matrix}\right]\\\text{grid}&amp; &amp; &amp;\text{adjacency}\end{matrix}\]</span></p>
</div>
</div>
<p>We can verify correctness for a any number of examples and also check if the grid is the tightest it can be:</p>
<div class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> check_tightness(a: npt.NDArray[np.int32], n: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Check if the solution is tight by removing the first and last row and column.</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">    a : np.ndarray[np.int32]</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">        The solution.</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">    n : number of labels.</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">    bool</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co">        True if none of the boundary rows or columns can be removed while maintaining</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co">        solution correctness.</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    tight <span class="op">=</span> <span class="va">True</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> a.size<span class="op">&gt;</span><span class="dv">0</span> <span class="kw">and</span> correct(count_neighbors(a[<span class="dv">1</span>:,:],n)):</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f'redundant first row for </span><span class="sc">{</span>n<span class="op">=</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        tight <span class="op">=</span> <span class="va">False</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> a.size<span class="op">&gt;</span><span class="dv">0</span> <span class="kw">and</span> correct(count_neighbors(a[:,<span class="dv">1</span>:],n)):</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f'redundant first col for </span><span class="sc">{</span>n<span class="op">=</span><span class="sc">}</span><span class="ss">'</span>)  </span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        tight <span class="op">=</span> <span class="va">False</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> a.size<span class="op">&gt;</span><span class="dv">0</span> <span class="kw">and</span> correct(count_neighbors(a[:<span class="op">-</span><span class="dv">1</span>,:],n)):</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f'redundant last row for </span><span class="sc">{</span>n<span class="op">=</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        tight <span class="op">=</span> <span class="va">False</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> a.size<span class="op">&gt;</span><span class="dv">0</span> <span class="kw">and</span> correct(count_neighbors(a[:,:<span class="op">-</span><span class="dv">1</span>],n)):</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f'redundant last col for </span><span class="sc">{</span>n<span class="op">=</span><span class="sc">}</span><span class="ss">'</span>)   </span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        tight <span class="op">=</span> <span class="va">False</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tight</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> verify_method(n: <span class="bu">int</span>, method: typing.Callable[[<span class="bu">int</span>], npt.NDArray[np.int32]]) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Verify that the method returns a correct solution for n.</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a><span class="co">    n : int</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a><span class="co">        The number of players.</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a><span class="co">    method : Callable[[int], np.ndarray[np.int32]]</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a><span class="co">        The method to be tested.</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>    a<span class="op">=</span>method(n)</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> correct(count_neighbors(a,n)), (n, a)</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>    check_tightness(a,n)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Applything this to the first 200 values of <span class="math inline">\(n\)</span> using the players handshake algorithm, we get the following:</p>
<div class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">200</span>):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    verify_method(n, players_handshake_grid)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>redundant first col for n=4
redundant last col for n=4</code></pre>
</div>
</div>
<p>Similarly, applying this to the first 200 values of <span class="math inline">\(n\)</span> using the basic solution, we get the following:</p>
<div class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">200</span>):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    verify_method(n, basic_solution_grid)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>redundant first row for n=2
redundant first col for n=2
redundant last row for n=2
redundant last col for n=2
redundant first row for n=4
redundant first col for n=4
redundant last row for n=4
redundant first col for n=5</code></pre>
</div>
</div>
<p>It is possible to show that the players handshake algorithm is not optimal in terms of grid size. For example, for <span class="math inline">\(n=10\)</span>, the algorithm generates a grid of size <span class="math inline">\(5 \times 10\)</span>:</p>
<div class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>disp_arrays_horiz(</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    (players_handshake_grid(<span class="dv">10</span>), <span class="st">'players handshake grid $n=10$'</span>), </span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    (count_neighbors(players_handshake_grid(<span class="dv">10</span>),<span class="dv">10</span>), <span class="st">'adjacency matrix'</span>))</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> correct(count_neighbors(players_handshake_grid(<span class="dv">10</span>),<span class="dv">10</span>))</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> check_tightness(players_handshake_grid(<span class="dv">10</span>),<span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><span class="math display">\[\begin{matrix}\left[\begin{matrix}9 &amp; 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8\\7 &amp; 8 &amp; 9 &amp; 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6\\4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp; 0 &amp; 1 &amp; 2 &amp; 3\\0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9\\5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp; 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4\end{matrix}\right]&amp; &amp; &amp;\left[\begin{matrix}0 &amp; 5 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 1 &amp; 1 &amp; 1 &amp; 4\\5 &amp; 0 &amp; 5 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 1 &amp; 1 &amp; 1\\1 &amp; 5 &amp; 0 &amp; 5 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 1 &amp; 1\\1 &amp; 1 &amp; 5 &amp; 0 &amp; 4 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 1\\1 &amp; 1 &amp; 1 &amp; 4 &amp; 0 &amp; 4 &amp; 1 &amp; 1 &amp; 1 &amp; 2\\2 &amp; 1 &amp; 1 &amp; 1 &amp; 4 &amp; 0 &amp; 5 &amp; 1 &amp; 1 &amp; 1\\1 &amp; 2 &amp; 1 &amp; 1 &amp; 1 &amp; 5 &amp; 0 &amp; 4 &amp; 1 &amp; 1\\1 &amp; 1 &amp; 2 &amp; 1 &amp; 1 &amp; 1 &amp; 4 &amp; 0 &amp; 5 &amp; 1\\1 &amp; 1 &amp; 1 &amp; 2 &amp; 1 &amp; 1 &amp; 1 &amp; 5 &amp; 0 &amp; 4\\4 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 1 &amp; 1 &amp; 1 &amp; 4 &amp; 0\end{matrix}\right]\\\text{players handshake grid $n=10$}&amp; &amp; &amp;\text{adjacency matrix}\end{matrix}\]</span></p>
</div>
</div>
<p>But here is a grid of size <span class="math inline">\(5 \times 8\)</span> that is also a solution:</p>
<div class="cell" data-execution_count="48">
<div class="cell-output cell-output-display">
<p><span class="math display">\[\begin{matrix}\left[\begin{matrix}1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8\\3 &amp; 5 &amp; 7 &amp; 9 &amp; 0 &amp; 2 &amp; 4 &amp; 6\\7 &amp; 0 &amp; 4 &amp; 8 &amp; 1 &amp; 5 &amp; 9 &amp; 2\\4 &amp; 1 &amp; 9 &amp; 6 &amp; 3 &amp; 0 &amp; 8 &amp; 5\\9 &amp; 3 &amp; 8 &amp; 2 &amp; 7 &amp; 1 &amp; 6 &amp; 0\end{matrix}\right]&amp; &amp; &amp;\left[\begin{matrix}0 &amp; 3 &amp; 1 &amp; 1 &amp; 1 &amp; 4 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\3 &amp; 0 &amp; 1 &amp; 3 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 3 &amp; 3 &amp; 1 &amp; 1 &amp; 1\\1 &amp; 3 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 3 &amp; 1 &amp; 1\\1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 3 &amp; 1 &amp; 4\\4 &amp; 1 &amp; 3 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\1 &amp; 1 &amp; 3 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 3 &amp; 1\\1 &amp; 1 &amp; 1 &amp; 3 &amp; 3 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1\\1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 3 &amp; 1 &amp; 0 &amp; 3\\1 &amp; 1 &amp; 1 &amp; 1 &amp; 4 &amp; 1 &amp; 1 &amp; 1 &amp; 3 &amp; 0\end{matrix}\right]\\\text{a solution grid for $n=10$}&amp; &amp; &amp;\text{adjacency matrix}\end{matrix}\]</span></p>
</div>
</div>
<p>The solutions Ive shown here have a simple implementation and, especially the players handshake, is what I need for the original problem I was trying to solve: Distinct-color palette visualization. The other goal I had was to see how flexible and convenient it is to use the tools I used to create this post. I think Ive achieved both goals. I hope you enjoyed reading this post as much as I enjoyed writing it. If you have any questions or suggestions, please leave a comment below. Thanks for reading!</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="omasoud/blog-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>